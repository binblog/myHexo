---
title: 一句话设计模式
date: 2016-11-06 17:18:06
toc: true
tags:
---
简单记录个人对设计模式理解，错漏之处，还望指出
<!--more-->

## 创建型模式
### 简单工厂
客户不需要创建对象实例，由一个工厂类创建的具体产品类
```
class  Factory {
    public static Component getComponent(int type) {    // type由客户指定或从配置中读取
        ...
    }
}
```
### 工厂方法
在工厂类中增加一个抽象工厂定义，产品类的实例化过程延迟到工厂子类完成（允许系统在不修改具体工厂角色的情况下引进新的产品）    
### 抽象工厂
使用一个工厂等级结构创建出属于不同产品等级结构的一个产品族中的所有对象  
切换产品族的时候，只要提供不同的抽象工厂实现就可以  
系统可以根据构件依赖定制抽象工厂，也可以由客户定制抽象工厂，提供给系统使用。  
缺点：如果给整个产品族添加一个新的产品，那么就需要修改抽象工厂类，这样就会导致必须修改所有的工厂实现类。  
![image](http://ofbrwsjmr.bkt.clouddn.com/design_patterns/1.png)
![image](http://ofbrwsjmr.bkt.clouddn.com/design_patterns/2.png)




### 单例
确保构件只有一个实例，并且构件需要向整个系统提供这个实例。
###  创建者
构件使用创建者实现构件实例化的细节。  
如果对象构造方法参数过多，可以使用内部创建者构造对象。  

### 原型
通过复制这个原型对象的办法创建出更多同类型的对象  
如果对象需要深度复制，可以实现clone方法  


## 结构型模式  
### 适配器
常用于转化api  

### 桥梁 
...

### 合成（组合）
对于树结构关系的对象，将个体对象（叶子结点）和容器对象（非叶子结果）作同样处理（实现相同的接口），让客户可以将他们一致对待。 
典型：把目录和文件当做同一种对象对待和处理  

### 装饰
装饰者继承构件，和构件提供一样的接口，但装饰会添加额外的逻辑
可以将aop中的代理类视为装饰者
典型：Java I/O标准库的设计
![image](http://ofbrwsjmr.bkt.clouddn.com/design_patterns/3.png)


### 外观（门面）
外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用，也减少外部系统与的耦合。

![image](http://ofbrwsjmr.bkt.clouddn.com/design_patterns/4.png)



### 享元
以共享的方式高效地支持大量的细粒度对象
![image](http://ofbrwsjmr.bkt.clouddn.com/555.png)  
简单工厂FlyweightFactory负责创建和管理享元角色，他必须保证享元对象可以被系统适当地共享。  
典型：string  
享元是对象级别的, 即多处使用到相同内容对象的地方只需要使用同一个对象即可, 而单例是类级别的, 即这个类必须只能实例化出来一个对象。


代理模式：构件提供一个代理对象，并由代理对象控制对的引用。
在某些情况下，客户不想或者不能够直接引用构件，而代理对象可以在客户端和客户之间起到中介的作用。  
![image](http://ofbrwsjmr.bkt.clouddn.com/666.png)


## 行为型模式  
### 责任链
每个链节对象都持有下一链节的引用从而连接起来形成一条责任链。请求在这个链上传递， 每个链节处理完后将请求传递给下一个链节。  
客户并不知道具体哪一链节处理了这个请求，所以系统可以在不影响客户的情况下动态地重新组织和分配责任。   
客户也可以根据需要自行组合责任链。  
典型：Tomcat中的Filter，netty的ChannelHandler

### 模板方法
抽象类定义一系列抽象方法（这些方法会被系统逻辑所调用），这些方法（钩子方法）由客户具体实现。客户可以以不同的方式实现这些抽象方法，从而实现自己的逻辑。  
典型：HttpService类中的service()方法会调用doPost/doPut/doDelete/doGet等方法，而这些do...方法则客户自行实现。

### 解释器
给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。  

### 命令
将一个请求或者操作封装到对象中。命令模式使请求方与执行方解耦，系统可以轻松实现命令队列，命令日志化，撤销和恢复，复合命令或扩展新的命令


### 迭代器
客户可以通过迭代器顺序地访问一个聚集中的元素而不必暴露聚集的内部元素。    
遍历算法被封装在迭代器中，迭代的算法可以独立于聚集角色变化，聚集角色也可以实现多个迭代器  
方法1：由聚集对象实现迭代方法next，如java.sql.ResultSet
```
ResultSet rs;
while(rs.next()) {
    Object o = rs.getObject(i);
}
```
方法2：由聚集对象创建的iterator实现迭代方法next，如果java.util.List
```
List<String> list ;
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
}
```


### 中介者
增加一个中介者对象，构件间的相互调用需要通过中介者调度。当构件间相互作用发生改变时，不会立即影响到其他构件之间的相互作用。从而保证这些相互作用可以彼此独立地变化。  
构件间解耦，中介者集中控制交互，多对多关系变成一对多关系  
缺点：  
调停者过于复杂

![image](http://ofbrwsjmr.bkt.clouddn.com/777.jpg)





### 备忘录
备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。  


### 状态
将构件的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。  
状态模式可以帮助避免if-else子句或者switch-case条件判定逻辑。
![image](http://ofbrwsjmr.bkt.clouddn.com/design_patterns/8.png)



### 策略
针对一组算法，将每一种算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。  
策略模式的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，所以实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。

**状态模式与策略模式区别**  
状态模式根据不同的状态来决定具体行为，一种状态下只能有一种行为
![](http://ofbrwsjmr.bkt.clouddn.com/design_patterns/9.png)


策略模式强调的是平等性与可替换性，所有策略是同一行为的不同实现，客户根据需要选择一种策略
![](http://ofbrwsjmr.bkt.clouddn.com/design_patterns/10.png)



### 访问者
```
// 访问者
interface Visitor {
    void visit(Component c);    // 接收构件作为参数并作具体处理
}

// 构件
public Class Component {
    public int accept(Visitor visitor) {    // 接收访问者作为参数，并调用visit方法
        visitor.visit(this);    // 将自身传递给访问者
    }
}
```
事件回调也可以视为一种访问者模式
```
button.setOnClickListener(new Button.OnClickListener() {    // 访问者Button.OnClickListener
    public void onClick(View v) {   // 将构件View传递给访问者
        ...
    }
});
```


### 观察者（发布-订阅）
让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够做相应处理。

推模型:主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或大部分数据。

拉模型:主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取。
java.util.Observable类/Observer接口，提供了对观察者模式的支持。

观察者模式类似访问者模式的加强，支持一系列的观察者，构件更新时通知所有的观察者，并实现添加/移除观察者的操作。

参考：  
[java_my_life](http://www.cnblogs.com/java-my-life/)  
[细数JDK里的设计模式](http://it.deepinmind.com/designpattern/2014/03/10/DP-in-JDK.html)